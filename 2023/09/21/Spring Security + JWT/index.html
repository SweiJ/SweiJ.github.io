<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Spring Security + JWT简述 | SweiJ的博客 | 望开开心心每一天！</title>

  
  <meta name="author" content="Swei">
  

  
  <meta name="description" content="日常随笔">
  

  
  <meta name="keywords" content="随笔">
  

  <meta id="viewport" name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">

  <meta property="og:title" content="Spring Security + JWT简述"/>

  <meta property="og:site_name" content="SweiJ的博客"/>

  
  <meta property="og:image" content="/favicon.ico"/>
  

  <link href="/favicon.ico" rel="icon">
  <link rel="alternate" href="/atom.xml" title="SweiJ的博客" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
<div class="blog">
  <div class="content">

    <header>
  <div class="site-branding">
    <h1 class="site-title">
      <a href="/">SweiJ的博客</a>
    </h1>
    <p class="site-description">望开开心心每一天！</p>
  </div>
  <nav class="site-navigation">
    <ul>
      
        <li><a href="/">主页</a></li>
      
        <li><a href="/archives">归档</a></li>
      
        <li><a href="/categories">分类</a></li>
      
        <li><a href="/tags">标签</a></li>
      
    </ul>
  </nav>
</header>

    <main class="site-main posts-loop">
    <article>

  
    
    <h3 class="article-title"><span>Spring Security + JWT简述</span></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2023/09/21/Spring Security + JWT/" rel="bookmark">
        <time class="entry-date published" datetime="2023-09-21T01:26:51.000Z">
          2023-09-21
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h1 id="一-什么是Spring-Security"><a href="#一-什么是Spring-Security" class="headerlink" title="一. 什么是Spring Security"></a>一. 什么是Spring Security</h1><blockquote>
<p>Spring Security是Spring家族的一个安全管理框架, 相比于另一个安全框架Shiro, 它具有更丰富的功能。一般中大型项目都是使用SpringSecurity做安全框架, 而Shiro上手比较简单</p>
</blockquote>
<p>spring security 的核心功能:</p>
<ul>
<li><p>认证(你是谁): 只有你的用户名或密码正确才能访问某些资源</p>
</li>
<li><p>授权(你能干嘛): 当前用户具有哪些功能, 将资源进行划分, 如在公司中分为普通资料和高级资料, 只有经理用户以上才能访文高级资料, 其他人只能拥有访问普通资料的权限。</p>
 <span id="more"></span></li>
</ul>
<h2 id="1-登陆校验的流程"><a href="#1-登陆校验的流程" class="headerlink" title="1. 登陆校验的流程"></a>1. 登陆校验的流程</h2><p><img src="https://img-blog.csdnimg.cn/f78850412d8a4fa79bb9b275531086ad.png" alt="在这里插入图片描述"></p>
<h2 id="2-SpringSecurity基础案例"><a href="#2-SpringSecurity基础案例" class="headerlink" title="2. SpringSecurity基础案例"></a>2. SpringSecurity基础案例</h2><p>首先创建一个Springboot的项目</p>
<p>添加依赖</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-security<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>创建一个controller类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/hello&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>启动项目访问<code>http://localhost:8080/login</code>, 发现页面并没有hello字符, 下图是SpringSeurity默认的登陆界面, 默认用户名为user, 密码为启动项目时在输出框中的内容</p>
<p><img src="https://img-blog.csdnimg.cn/929a1f992b01446bacd88655832940c8.png" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/bd359715ccf644f7b6289d24f2c56aa4.png" alt="在这里插入图片描述"><br>在实际项目中, 显然不能使用默认的登陆界面, 所以我们需要自定义登陆认证和授权</p>
<h1 id="二-Spring-Security原理流程"><a href="#二-Spring-Security原理流程" class="headerlink" title="二. Spring Security原理流程"></a>二. Spring Security原理流程</h1><p>SpringSecurity底层实现是一系列过滤器链</p>
<p>默认自动配置的过滤器<br><img src="https://img-blog.csdnimg.cn/e783a882bb0e4df181f6054288e34e8f.png" alt="在这里插入图片描述"></p>
<table>
<thead>
<tr>
<th>过滤器</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>WebAsyncManagerIntegrationFilter</td>
<td>将WebAsyncManger与SpringSecurity上下文进行集成</td>
</tr>
<tr>
<td>SecurityContextPersistenceFilter</td>
<td>在处理请求之前, 将安全信息加载到SecurityContextHolder中</td>
</tr>
<tr>
<td>HeaderWriterFilter</td>
<td>处理头信息假如响应中</td>
</tr>
<tr>
<td>CsrfFilter</td>
<td>处理CSRF攻击</td>
</tr>
<tr>
<td>LogoutFilter</td>
<td>处理注销登录</td>
</tr>
<tr>
<td>UsernamePasswordAuthenticationFilter</td>
<td>处理表单登录</td>
</tr>
<tr>
<td>DefaultLoginPageGeneratingFilter</td>
<td>配置默认登录页面</td>
</tr>
<tr>
<td>DefaultLogoutPageGeneratingFilter</td>
<td>配置默认注销页面</td>
</tr>
<tr>
<td>BasicAuthenticationFilter</td>
<td>处理HttpBasic登录</td>
</tr>
<tr>
<td>RequestCacheAwareFilter</td>
<td>处理请求缓存</td>
</tr>
<tr>
<td>SecurityContextHolderAwareRequestFilter</td>
<td>包装原始请求</td>
</tr>
<tr>
<td>AnonymousAuthenticationFilter</td>
<td>配置匿名认证</td>
</tr>
<tr>
<td>SessionManagementFilter</td>
<td>处理session并发问题</td>
</tr>
<tr>
<td>ExceptionTranslationFilter</td>
<td>处理认证&#x2F;授权中的异常</td>
</tr>
<tr>
<td>FilterSecurityInterceptor</td>
<td>处理授权相关</td>
</tr>
</tbody></table>
<p>下图是主要的过滤器<br><img src="https://img-blog.csdnimg.cn/55acb4e7ed454a9697c062f889594fa6.png" alt="在这里插入图片描述"></p>
<p>上图只画出了核心的过滤器</p>
<p><strong>UsernamePasswordAuthenticationFilter</strong>: 负责处理登陆页面填写的用户名和密码的登陆请求</p>
<p><strong>ExceptionTranslationFilter</strong>: 处理过滤器链中抛出的任何AccessDeniedException和AuthenticationException异常</p>
<p><strong>FilterSecurityInterceptor</strong>: 负责权限校验的过滤器</p>
<h2 id="1-大致流程"><a href="#1-大致流程" class="headerlink" title="1. 大致流程"></a>1. 大致流程</h2><p><img src="https://img-blog.csdnimg.cn/e7f09bb8bded468ca79e1fab09a24356.png" alt="在这里插入图片描述"><br><strong>(1)</strong>  下面是<code>UsernamePasswordAuthenticationFilter</code>中的<code>attemptAuthentication</code>方法,  该方法会将前端发送的用户名和密码封装为<code>UsernamePasswordAuthenticationToken</code>对象, 该对象是<code>Authentication</code>对象的实现类</p>
<p>注意: <code>attemptAuthentication</code>方法主要处理视图表单认证, 现今都是前后端分离项目导致不能使用该方法进行拦截, 所以我们需要自己实现一个过滤器覆盖或者在<code>UsernamePasswordAuthenticationFilter</code>之前做用户名和密码拦截处理.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Authentication <span class="title function_">attemptAuthentication</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> AuthenticationException &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.postOnly &amp;&amp; !request.getMethod().equals(<span class="string">&quot;POST&quot;</span>)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AuthenticationServiceException</span>(<span class="string">&quot;Authentication method not supported: &quot;</span> + request.getMethod());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> <span class="built_in">this</span>.obtainUsername(request);</span><br><span class="line">        <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> <span class="built_in">this</span>.obtainPassword(request);</span><br><span class="line">        <span class="keyword">if</span> (username == <span class="literal">null</span>) &#123;</span><br><span class="line">            username = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (password == <span class="literal">null</span>) &#123;</span><br><span class="line">            password = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        username = username.trim();</span><br><span class="line">        <span class="type">UsernamePasswordAuthenticationToken</span> <span class="variable">authRequest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UsernamePasswordAuthenticationToken</span>(username, password);</span><br><span class="line">        <span class="built_in">this</span>.setDetails(request, authRequest);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.getAuthenticationManager().authenticate(authRequest);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>(2)</strong> 返回<code>getAuthenticationManager.authenticate(authRequest)</code>, 将未认证的<code>Authentication</code>对象传入<code>AuthenticationManager</code> , 进入<code>authenticate</code>方法我们看到<code>AuthenticationManager</code>是一个接口, 该接口主要做认证管理, 它的默认实现类是<code>ProviderManager</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AuthenticationManager</span> &#123;</span><br><span class="line">    Authentication <span class="title function_">authenticate</span><span class="params">(Authentication var1)</span> <span class="keyword">throws</span> AuthenticationException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>(3)</strong> 在SpringSecurity中, 在项目中支持多种不同方式的认证方式, 不同的认证方式对应不同的<code>AuthenticationProvider</code>,  多个<code>AuthenticationProvider</code> 组成一个列表, 这个列表由<code>ProviderManager</code>代理, 在<code>ProviderManager</code>中遍历列表中的每一个<code>AuthenticationProvider</code>进行认证</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Authentication <span class="title function_">authenticate</span><span class="params">(Authentication authentication)</span> <span class="keyword">throws</span> AuthenticationException &#123;</span><br><span class="line">    Class&lt;? <span class="keyword">extends</span> <span class="title class_">Authentication</span>&gt; toTest = authentication.getClass();</span><br><span class="line">    <span class="type">AuthenticationException</span> <span class="variable">lastException</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">AuthenticationException</span> <span class="variable">parentException</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">Authentication</span> <span class="variable">result</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">Authentication</span> <span class="variable">parentResult</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">debug</span> <span class="operator">=</span> logger.isDebugEnabled();</span><br><span class="line">    <span class="comment">// 迭代遍历认证列表</span></span><br><span class="line">    <span class="type">Iterator</span> <span class="variable">var8</span> <span class="operator">=</span> <span class="built_in">this</span>.getProviders().iterator();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(var8.hasNext()) &#123;</span><br><span class="line">    	<span class="comment">// 取出当前认证</span></span><br><span class="line">        <span class="type">AuthenticationProvider</span> <span class="variable">provider</span> <span class="operator">=</span> (AuthenticationProvider)var8.next();</span><br><span class="line">        <span class="comment">// 当前认证是否支持当前的用户名和密码信息</span></span><br><span class="line">        <span class="keyword">if</span> (provider.supports(toTest)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (debug) &#123;</span><br><span class="line">                logger.debug(<span class="string">&quot;Authentication attempt using &quot;</span> + provider.getClass().getName());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">            	<span class="comment">// 开始做认证处理</span></span><br><span class="line">                result = provider.authenticate(authentication);</span><br><span class="line">                <span class="keyword">if</span> (result != <span class="literal">null</span>) &#123;</span><br><span class="line">                	<span class="comment">// 认证成功时候返回</span></span><br><span class="line">                    <span class="built_in">this</span>.copyDetails(authentication, result);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InternalAuthenticationServiceException | AccountStatusException var13) &#123;</span><br><span class="line">                <span class="built_in">this</span>.prepareException(var13, authentication);</span><br><span class="line">                <span class="keyword">throw</span> var13;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (AuthenticationException var14) &#123;</span><br><span class="line">                lastException = var14;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 不支持当前认证并且parent支持该认证</span></span><br><span class="line">    <span class="keyword">if</span> (result == <span class="literal">null</span> &amp;&amp; <span class="built_in">this</span>.parent != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            result = parentResult = <span class="built_in">this</span>.parent.authenticate(authentication);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ProviderNotFoundException var11) &#123;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (AuthenticationException var12) &#123;</span><br><span class="line">            parentException = var12;</span><br><span class="line">            lastException = var12;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (result != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.eraseCredentialsAfterAuthentication &amp;&amp; result <span class="keyword">instanceof</span> CredentialsContainer) &#123;</span><br><span class="line">            ((CredentialsContainer)result).eraseCredentials();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (parentResult == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.eventPublisher.publishAuthenticationSuccess(result);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (lastException == <span class="literal">null</span>) &#123;</span><br><span class="line">            lastException = <span class="keyword">new</span> <span class="title class_">ProviderNotFoundException</span>(<span class="built_in">this</span>.messages.getMessage(<span class="string">&quot;ProviderManager.providerNotFound&quot;</span>, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;toTest.getName()&#125;, <span class="string">&quot;No AuthenticationProvider found for &#123;0&#125;&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (parentException == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.prepareException((AuthenticationException)lastException, authentication);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">throw</span> lastException;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>拓展:<br><code>ProviderManager</code>可以配置一个<code>AuthenticationManager</code>作为parent, 当<code>ProviderManager</code>认证失败后, 可以进入parent中再次进行认证, 通常由<code>ProviderManager</code>来充当parent的角色, 即<code>ProviderManager</code>是<code>ProviderManager</code>的parent<br><code>ProviderManager</code>可以有多个, 而多个<code>ProviderManager</code>共用一个parent</p>
<p><img src="https://img-blog.csdnimg.cn/8426175c37764d13a723a7c9b2b43431.png" alt="在这里插入图片描述"></p>
<p><strong>(4)</strong> 当前<code>AuthenticationProvider</code>支持认证时, 会进入<code>AuthenticationProvider</code>的<code>authenticate</code>方法, 而<code>AuthenticationProvider</code>是一个接口, 它的实现类是<code>AbstractUserDetailsAuthenticationProvider</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Authentication <span class="title function_">authenticate</span><span class="params">(Authentication authentication)</span> <span class="keyword">throws</span> AuthenticationException &#123;</span><br><span class="line">    Assert.isInstanceOf(UsernamePasswordAuthenticationToken.class, authentication, () -&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.messages.getMessage(<span class="string">&quot;AbstractUserDetailsAuthenticationProvider.onlySupports&quot;</span>, <span class="string">&quot;Only UsernamePasswordAuthenticationToken is supported&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 获取当前authentication的信息</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> authentication.getPrincipal() == <span class="literal">null</span> ? <span class="string">&quot;NONE_PROVIDED&quot;</span> : authentication.getName();</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">cacheWasUsed</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 在缓存中查看username</span></span><br><span class="line">    <span class="type">UserDetails</span> <span class="variable">user</span> <span class="operator">=</span> <span class="built_in">this</span>.userCache.getUserFromCache(username);</span><br><span class="line">    <span class="keyword">if</span> (user == <span class="literal">null</span>) &#123;</span><br><span class="line">        cacheWasUsed = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">        	<span class="comment">// 调用retrieveUser方法</span></span><br><span class="line">            user = <span class="built_in">this</span>.retrieveUser(username, (UsernamePasswordAuthenticationToken)authentication);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (UsernameNotFoundException var6) &#123;</span><br><span class="line">            <span class="built_in">this</span>.logger.debug(<span class="string">&quot;User &#x27;&quot;</span> + username + <span class="string">&quot;&#x27; not found&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.hideUserNotFoundExceptions) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BadCredentialsException</span>(<span class="built_in">this</span>.messages.getMessage(<span class="string">&quot;AbstractUserDetailsAuthenticationProvider.badCredentials&quot;</span>, <span class="string">&quot;Bad credentials&quot;</span>));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">throw</span> var6;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Assert.notNull(user, <span class="string">&quot;retrieveUser returned null - a violation of the interface contract&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.preAuthenticationChecks.check(user);</span><br><span class="line">        <span class="built_in">this</span>.additionalAuthenticationChecks(user, (UsernamePasswordAuthenticationToken)authentication);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (AuthenticationException var7) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!cacheWasUsed) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var7;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        cacheWasUsed = <span class="literal">false</span>;</span><br><span class="line">        user = <span class="built_in">this</span>.retrieveUser(username, (UsernamePasswordAuthenticationToken)authentication);</span><br><span class="line">        <span class="built_in">this</span>.preAuthenticationChecks.check(user);</span><br><span class="line">        <span class="comment">// 密码的加密处理</span></span><br><span class="line">        <span class="built_in">this</span>.additionalAuthenticationChecks(user, (UsernamePasswordAuthenticationToken)authentication);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.postAuthenticationChecks.check(user);</span><br><span class="line">    <span class="keyword">if</span> (!cacheWasUsed) &#123;</span><br><span class="line">        <span class="built_in">this</span>.userCache.putUserInCache(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">Object</span> <span class="variable">principalToReturn</span> <span class="operator">=</span> user;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.forcePrincipalAsString) &#123;</span><br><span class="line">        principalToReturn = user.getUsername();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.createSuccessAuthentication(principalToReturn, authentication, user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>(5)</strong> <code>retrieveUser</code>在<code>AbstractUserDetailsAuthenticationProvider</code>中有<code>retrieveUser</code>方法, 但是实现该方法的对象是<code>DaoAuthenticationProvider</code>, 该对象重写了<code>retrieveUser</code>方法, 在<code>retrieveUser</code>方法中, 可以看到调用了<code>UserDetailsService</code>的<code>loadUserByUsername()</code>方法, 该方法用来根据用户名查询内存或者其他数据源中的用户. 默认是基于内存查找, 我们可以自定义为数据库查询. 查询后的结果封装成<code>UserDetails</code> 对象, 该对象包含用户名、加密密码、权限以及账户相关信息. 密码的加密处理是SpringSecurity帮我们处理</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> UserDetails <span class="title function_">retrieveUser</span><span class="params">(String username, UsernamePasswordAuthenticationToken authentication)</span> <span class="keyword">throws</span> AuthenticationException &#123;</span><br><span class="line">    <span class="built_in">this</span>.prepareTimingAttackProtection();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">    	<span class="comment">// 调用该方法返回一个UserDetails 对象</span></span><br><span class="line">        <span class="type">UserDetails</span> <span class="variable">loadedUser</span> <span class="operator">=</span> <span class="built_in">this</span>.getUserDetailsService().loadUserByUsername(username);</span><br><span class="line">        <span class="keyword">if</span> (loadedUser == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InternalAuthenticationServiceException</span>(<span class="string">&quot;UserDetailsService returned null, which is an interface contract violation&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> loadedUser;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (UsernameNotFoundException var4) &#123;</span><br><span class="line">        <span class="built_in">this</span>.mitigateAgainstTimingAttack(authentication);</span><br><span class="line">        <span class="keyword">throw</span> var4;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InternalAuthenticationServiceException var5) &#123;</span><br><span class="line">        <span class="keyword">throw</span> var5;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception var6) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InternalAuthenticationServiceException</span>(var6.getMessage(), var6);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="三-JWT"><a href="#三-JWT" class="headerlink" title="三. JWT"></a>三. JWT</h1><h2 id="1-什么是JWT"><a href="#1-什么是JWT" class="headerlink" title="1. 什么是JWT?"></a>1. 什么是JWT?</h2><p>JWT主要用于用户登陆鉴权, 在之前可能会使用session和token认证, 下面简述三者session和JWT的区别</p>
<p><strong>Session</strong></p>
<p>用户向服务器发送一个请求时, 服务器并不知道该请求是谁发的, 所以在用户发送登录请求时, 服务器会将用户提交的用户名和密码等信息保存在session会话中(一段内存空间)。同时服务器保存的用户信息会生成一个sessionid(相当于用户信息是一个value值, 而sessionid是value值的key)返回给客户端, 客户端将sessionid保存到cookie中, 等到下一次请求客户端会将cookie一同请求给服务器做认证</p>
<p>如果用户过多, 必然会耗费大量内存, 在cookie中存放sessionid会存在暴露用户信息的风险 </p>
<p><strong>Token</strong></p>
<p>token是一串随机的字符串也叫令牌, 其原理和session类似, 当用户登录时, 提交的用户名和密码等信息请求给服务端, 服务端会根据用户名或者其他信息生成一个token而不是sessionid, 这和sessionid唯一区别就是, token不再存储用户信息, 客户端下一次请求会携带token, 此时服务器根据此次token进行认证。</p>
<p>token认证时也会到数据库中查询, 会造成数据库压力过大。</p>
<p><strong>JWT</strong></p>
<p>JWT将登录时所有信息都存在自己身上, 并且以json格式存储, JWT不依赖Redis或者数据库, JWT安全性不太好, 所以不能存储敏感信息</p>
<h2 id="2-SpringSecurity集成JWT"><a href="#2-SpringSecurity集成JWT" class="headerlink" title="2. SpringSecurity集成JWT"></a>2. SpringSecurity集成JWT</h2><h3 id="1-认证配置"><a href="#1-认证配置" class="headerlink" title="(1) 认证配置"></a>(1) 认证配置</h3><p><strong>a) 配置SpringSecurity</strong></p>
<p>首先配置一个<code>SpringSecurity</code>的配置类, 因为是基于JWT进行认证, 所以需要在配置中禁用session机制, 并不是禁用整个系统的session功能</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableWebSecurity</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityConfig</span> <span class="keyword">extends</span> <span class="title class_">WebSecurityConfigurerAdapter</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserServiceImpl userDetailsService;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> LoginFilter loginFilter;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AuthFilter authFilter;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 禁用session机制 </span></span><br><span class="line">        http.csrf().disable()</span><br><span class="line">                .sessionManagement()</span><br><span class="line">                .sessionCreationPolicy(SessionCreationPolicy.STATELESS);</span><br><span class="line"></span><br><span class="line">        http.authorizeRequests()</span><br><span class="line">                <span class="comment">// 指定某些接口不需要通过验证即可访问。像登陆、注册接口肯定是不需要认证的</span></span><br><span class="line">                .antMatchers(<span class="string">&quot;/sec/login&quot;</span>).permitAll()</span><br><span class="line">                .anyRequest().authenticated()</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 自定义权限配置</span></span><br><span class="line">                .withObjectPostProcessor(<span class="keyword">new</span> <span class="title class_">ObjectPostProcessor</span>&lt;FilterSecurityInterceptor&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> &lt;O <span class="keyword">extends</span> <span class="title class_">FilterSecurityInterceptor</span>&gt; O <span class="title function_">postProcess</span><span class="params">(O o)</span> &#123;</span><br><span class="line">                        o.setAccessDecisionManager(customUrlDecisionManager);</span><br><span class="line">                        o.setSecurityMetadataSource(customFilter);</span><br><span class="line">                        <span class="keyword">return</span> o;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">                .and()</span><br><span class="line">                <span class="comment">// 禁用缓存</span></span><br><span class="line">                .headers()</span><br><span class="line">                .cacheControl();</span><br><span class="line"></span><br><span class="line">        http.addFilterBefore(jwtAuthencationTokenFilter(), UsernamePasswordAuthenticationFilter.class);</span><br><span class="line">        <span class="comment">// 添加自定义未授权和未登陆结果返回</span></span><br><span class="line">        http.exceptionHandling()</span><br><span class="line">                .accessDeniedHandler(restfulAccessDeniedHandler)</span><br><span class="line">                .authenticationEntryPoint(restAuthoricationEntryPoint);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(AuthenticationManagerBuilder auth)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 指定UserDetailService和加密器</span></span><br><span class="line">        auth.userDetailsService(userDetailsService).passwordEncoder(passwordEncoder());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> AuthenticationManager <span class="title function_">authenticationManager</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.authenticationManager();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span>     </span><br><span class="line">    <span class="keyword">public</span> PasswordEncoder <span class="title function_">passwordEncoder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">BCryptPasswordEncoder</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>b) 实现登录接口</strong></p>
<p>先按照正常流程, 实现一个登录的接口然后在业务层中实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/login&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Res <span class="title function_">login</span><span class="params">(<span class="meta">@RequestBody</span> User user, HttpServletRequest request)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> userService.login(user, request);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在业务层中, 首先对密码和用户名进行检验, 然后更新security登录用户对象, 在此之前我们先来认识几个在<code>SpringSecurity</code>中重要的变量</p>
<p><code>Authentication</code>: 存储了认证信息, 代表登录用户<br><code>SecurityContext</code>: 上下文对象, 用来获取<code>Authentication</code>(用户信息)<br><code>SecurityContextHolder</code>: 上下文管理对象, 用来在程序任何地方获取<code>SecurityContext</code><br><code>UserDetails</code>: 存储了用户的基本信息, 以及用户权限、是否被禁用等</p>
<p>在<code>Authentication</code>中的认证信息有<br><code>Principal</code>: 用户信息<br><code>Credentials</code>: 用户凭证, 一般是密码<br><code>Authorities</code>: 用户权限</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Res <span class="title function_">login</span><span class="params">(User user, HttpServletRequest request)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> user.getUsername();</span><br><span class="line">    <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> user.getPassword();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 登陆 检测</span></span><br><span class="line">    <span class="type">UserDetails</span> <span class="variable">userDetails</span> <span class="operator">=</span> userDetailsService.loadUserByUsername(username);</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">null</span> == userDetails || !passwordEncoder.matches(password, userDetails.getPassword())) &#123;</span><br><span class="line">        <span class="keyword">return</span> Res.error(<span class="string">&quot;用户名或密码不正确!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 更新security登录用户对象</span></span><br><span class="line">    <span class="type">UsernamePasswordAuthenticationToken</span> <span class="variable">authenticationToken</span> <span class="operator">=</span> <span class="keyword">new</span></span><br><span class="line">            <span class="title class_">UsernamePasswordAuthenticationToken</span>(userDetails,</span><br><span class="line">            <span class="literal">null</span>, userDetails.getAuthorities());</span><br><span class="line">    SecurityContextHolder.getContext().setAuthentication(authenticationToken);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个token</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> jwtTokenUtil.generateToken(userDetails);</span><br><span class="line">    Map&lt;String, String&gt; tokenMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    tokenMap.put(<span class="string">&quot;token&quot;</span>, token);</span><br><span class="line">    tokenMap.put(<span class="string">&quot;tokenHead&quot;</span>, tokenHead);</span><br><span class="line">    <span class="keyword">return</span> Res.success(<span class="string">&quot;登陆成功&quot;</span>, tokenMap);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面这行代码主要是在数据库或者缓存中查询用户提交的用户名以及用户的权限信息, 将这些信息保存在<code>userDetails</code>中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">UserDetails</span> <span class="variable">userDetails</span> <span class="operator">=</span> userDetailsService.loadUserByUsername(username);</span><br></pre></td></tr></table></figure>
<p><code>UsernamePasswordAuthenticationToken</code> 实现了<code>Authentication</code>, 也就是说此时将userDetails中的信息以及权限信息存放在<code>Authentication</code>中</p>
<p>创建Token需要JWT的工具类, 在网上随便找个都可以, 大致都一样, 这个只需要知道就行了</p>
<p><strong>c) 过滤请求</strong></p>
<p>在原生<code>SpringSecurity</code>中默认的拦截在<code>UsernamePasswordAuthenticationFilter</code>这个类中,该类主要拦截表单提交的用户名和密码, 显然在前后端分离项目中不适用, 而且我们用到了JWT的验证方式, 前端每次请求都需要带上token, 所以我们需要在后端对每个请求进行提前过滤拦截</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JwtAuthencationTokenFilter</span> <span class="keyword">extends</span> <span class="title class_">OncePerRequestFilter</span> &#123;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jwt.tokenHeader&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String tokenHeader;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jwt.tokenHead&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String tokenHead;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JwtTokenUtil jwtTokenUtil;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserDetailsService userDetailsService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doFilterInternal</span><span class="params">(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)</span></span><br><span class="line">            <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">// 请求头中获取token信息</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">authheader</span> <span class="operator">=</span> request.getHeader(tokenHeader);</span><br><span class="line">        <span class="comment">// 存在token</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="literal">null</span> != authheader &amp;&amp; authheader.startsWith(tokenHead)) &#123;</span><br><span class="line">            <span class="comment">// 去除字段名称, 获取真正token</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">authToken</span> <span class="operator">=</span> authheader.substring(tokenHead.length());</span><br><span class="line">            <span class="comment">// 利用token获取用户名</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> jwtTokenUtil.getUserNameFromToken(authToken);</span><br><span class="line">            <span class="comment">// token存在用户但未登陆</span></span><br><span class="line">            <span class="comment">// SecurityContextHolder.getContext().getAuthentication() 获取上下文对象中认证信息</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="literal">null</span> != username &amp;&amp; <span class="literal">null</span> == SecurityContextHolder.getContext().getAuthentication()) &#123;</span><br><span class="line">                <span class="comment">// 自定义数据源获取用户信息</span></span><br><span class="line">                <span class="type">UserDetails</span> <span class="variable">userDetails</span> <span class="operator">=</span> userDetailsService.loadUserByUsername(username);</span><br><span class="line">                <span class="comment">// 验证token是否有效 验证token用户名和存储的用户名是否一致以及是否在有效期内, 重新设置用户对象</span></span><br><span class="line">                <span class="keyword">if</span>(jwtTokenUtil.validateToken(authToken, userDetails)) &#123;</span><br><span class="line">                    <span class="comment">// 重新将用户信息封装到UsernamePasswordAuthenticationToken</span></span><br><span class="line">                    <span class="type">UsernamePasswordAuthenticationToken</span> <span class="variable">authenticationToken</span> <span class="operator">=</span> <span class="keyword">new</span></span><br><span class="line">                            <span class="title class_">UsernamePasswordAuthenticationToken</span>(userDetails, <span class="literal">null</span>, userDetails.getAuthorities());</span><br><span class="line">                    authenticationToken.setDetails(<span class="keyword">new</span> <span class="title class_">WebAuthenticationDetailsSource</span>().buildDetails(request));</span><br><span class="line">                    <span class="comment">// 将信息存入上下文对象</span></span><br><span class="line">                    SecurityContextHolder.getContext().setAuthentication(authenticationToken);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        filterChain.doFilter(request,response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该过滤器主要做的是: </p>
<ol>
<li>提取前端发送的请求头信息, 根据JWT的工具类获取用户名</li>
<li>如果请求头具有有效的字符串(也就是拥有用户信息)并且上下文对象存在用户信息(数据库或者缓存中查的用户信息)则直接到下一个过滤器, 否则请求头中有信息而当前上下文对象没有存储用户信息则将请求头中的用户在数据层验证之后重新放入上下文对象中(<code>UsernamePasswordAuthenticationToken</code>)。 </li>
<li>如果当前用户没有登录或者没有token信息(可能是token过期), 而当前请求的地址符合权限中包含的地址(也就是数据库中存在的), 则会进入权限验证(下面会讲)</li>
</ol>
<p>当然以上的逻辑可以自己自定义, 不管以上什么情况都会进入权限验证</p>
<p>要让这个过滤器加入到<code>SpringSecurity</code>的过滤器链中, 就需要在<code>SecurityConfig</code>类的<code>configure</code>方法添加下面一条语句, <code>addFilterBefore()</code>将<code>jwtAuthencationTokenFilter()</code>, 放在<code>UsernamePasswordAuthenticationFilter</code>之前</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http.addFilterBefore(jwtAuthencationTokenFilter(), UsernamePasswordAuthenticationFilter.class);</span><br></pre></td></tr></table></figure>

<h3 id="2-权限配置"><a href="#2-权限配置" class="headerlink" title="(2) 权限配置"></a>(2) 权限配置</h3><p>在一个项目中, 不同的用户需要具有不同的权限, 我们怎么对用户进行区分呢?</p>
<p><strong>a) RBAC权限表</strong></p>
<p>将用户、角色和权限绑定，这样可以知道某个用户具有哪些角色, 而某个角色对应有哪些权限（能干什么，不能干什么），这样就知道哪些用户拥有的角色和权限信息。</p>
<p>基于以上的想法, 我们需要三张实体表, 还需要两张多对多的关系表, 这样就构成了RBAC的五张表</p>
<p><strong>b) 授权流程</strong></p>
<p>在SpringSecurity中授权的过滤器是<code>FilterSecurityInterceptor</code></p>
<p>默认的流程</p>
<ul>
<li>调用<code>SecurityMetadataSource</code>获取当前请求的鉴权规则</li>
<li>接着调用<code>AccessDecisionManager</code> 来校验当前用户的是否拥有当前权限</li>
<li>如果有权限就放行, 否则抛出异常, 该异常则会被<code>AccessDeniedHandler</code>处理</li>
</ul>
<p><strong>c) 自定义<code>SecurityMetadataSource</code></strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomFilter</span> <span class="keyword">implements</span> <span class="title class_">FilterInvocationSecurityMetadataSource</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ResourceService resourceService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Collection&lt;ConfigAttribute&gt; <span class="title function_">getAttributes</span><span class="params">(Object o)</span> <span class="keyword">throws</span> IllegalArgumentException &#123;</span><br><span class="line">        <span class="type">HttpServletRequest</span> <span class="variable">request</span> <span class="operator">=</span> ((FilterInvocation) o).getRequest();</span><br><span class="line"></span><br><span class="line">        List&lt;Resource&gt; menus = resourceService.getResource();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Resource menu : menus) &#123;</span><br><span class="line">            String[] split = menu.getPath().split(<span class="string">&quot;:&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="type">AntPathRequestMatcher</span> <span class="variable">ant</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AntPathRequestMatcher</span>(split[<span class="number">1</span>]);</span><br><span class="line">            <span class="comment">// 如果请求方法和请求路径都匹配上了，则代表找到了这个请求所需的权限资源</span></span><br><span class="line">            <span class="keyword">if</span> (request.getMethod().equals(split[<span class="number">0</span>]) &amp;&amp; ant.matches(request)) &#123;</span><br><span class="line">                <span class="comment">// 将我们权限资源id返回</span></span><br><span class="line">                <span class="keyword">return</span> Collections.singletonList(<span class="keyword">new</span> <span class="title class_">SecurityConfig</span>(menu.getId().toString()));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Collection&lt;ConfigAttribute&gt; <span class="title function_">getAllConfigAttributes</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">supports</span><span class="params">(Class&lt;?&gt; aClass)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><code>FilterInvocationSecurityMetadataSource</code>继承<code>SecurityMetadataSource</code></p>
<p>在<code>getAttributes</code>方法中, o参数封装了<code>request</code>的相关信息, 可以从中获取请求的方法和URL等信息</p>
<p>然后menus得到的是当前数据层中所有的权限路径, 接着循环所有的路径信息与当前请求的方法和URL进行验证, 如果在数据层中没有当前请求则返回null, 否则将该权限的在数据层中的信息返回</p>
<p><strong>c) 自定义<code>AccessDecisionManager</code></strong> </p>
<p>如果在<code>SecurityMetadataSource</code>中有权限信息, 则会进入该方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomUrlDecisionManager</span> <span class="keyword">implements</span> <span class="title class_">AccessDecisionManager</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">decide</span><span class="params">(Authentication authentication, Object o, Collection&lt;ConfigAttribute&gt; collection)</span> <span class="keyword">throws</span> AccessDeniedException, InsufficientAuthenticationException &#123;</span><br><span class="line">        <span class="keyword">if</span>(Collections.isEmpty(collection)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (ConfigAttribute configAttribute : collection) &#123;</span><br><span class="line">            <span class="keyword">for</span> (GrantedAuthority authority : authentication.getAuthorities()) &#123;</span><br><span class="line">            	<span class="keyword">if</span>(<span class="string">&quot;ROLE_ANONYMOUS&quot;</span>.equals(authority.getAuthority())) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AccessDeniedException</span>(<span class="string">&quot;尚未登录, 请登录&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(Objects.equals(authority.getAuthority(), configAttribute.getAttribute())) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AccessDeniedException</span>(<span class="string">&quot;权限不足, 请联系管理员!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">supports</span><span class="params">(ConfigAttribute configAttribute)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">supports</span><span class="params">(Class&lt;?&gt; aClass)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先来看几个变量</p>
<ol>
<li>ConfigAttribute: 这个是鉴权的规则, 根据自己项目设定, 我们这里填入的是当前请求和数据层中相匹配的权限信息id</li>
<li>GrantedAuthority: 当前认证用户所拥有的权限信息</li>
</ol>
<p>在上述的<code>decide</code>方法中, 主要验证了用户所拥有的权限和当前请求的权限信息是否一致</p>
<p>如果不一致, 则抛出异常, 被<code>AccessDeniedHandler</code>处理</p>
<p><strong>d) 自定义<code>AccessDeniedHandler</code></strong> </p>
<p>自定义返回json格式数据</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RestfulAccessDeniedHandler</span> <span class="keyword">implements</span> <span class="title class_">AccessDeniedHandler</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, AccessDeniedException accessDeniedException)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        response.setCharacterEncoding(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        response.setContentType(<span class="string">&quot;application/json&quot;</span>);</span><br><span class="line">        <span class="type">PrintWriter</span> <span class="variable">out</span> <span class="operator">=</span> response.getWriter();</span><br><span class="line">        <span class="type">Res</span> <span class="variable">bean</span> <span class="operator">=</span> Res.error(<span class="string">&quot;权限不足, 请联系管理员!&quot;</span>);</span><br><span class="line">        bean.setCode(<span class="number">403</span>);</span><br><span class="line">        out.write(<span class="keyword">new</span> <span class="title class_">ObjectMapper</span>().writeValueAsString(bean));</span><br><span class="line">        out.flush();</span><br><span class="line">        out.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>e) 在<code>SpringSecurity</code>中的配置</strong></p>
<p>在configure方法中, 进行了动态权限配置</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.withObjectPostProcessor(<span class="keyword">new</span> <span class="title class_">ObjectPostProcessor</span>&lt;FilterSecurityInterceptor&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;O <span class="keyword">extends</span> <span class="title class_">FilterSecurityInterceptor</span>&gt; O <span class="title function_">postProcess</span><span class="params">(O o)</span> &#123;</span><br><span class="line">        o.setAccessDecisionManager(customUrlDecisionManager);</span><br><span class="line">        o.setSecurityMetadataSource(customFilter);</span><br><span class="line">        <span class="keyword">return</span> o;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>插入: 还有一个认证异常处理</p>
<ol>
<li>用户首次登录且验证成功, 此时正常用户权限授权</li>
<li>请求数据时, 非首次登录, 如果没有携带token(token过期), 又或者没有登录访问内部路径时, 说明没有认证权限不能访问, 抛出未登录异常</li>
<li>请求数据时, 有token信息, 而上下文对象中没有用户信息, 则会重新将用户信息放入上下文对象中, 接着进入权限验证, 如果用户拥有该权限则放行, 如果没有该权限则抛出权限不足异常</li>
</ol>
<p>在configure中配置未登录和未授权异常处理</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">http.exceptionHandling()</span><br><span class="line">                .accessDeniedHandler(restfulAccessDeniedHandler)</span><br><span class="line">                .authenticationEntryPoint(restAuthoricationEntryPoint);</span><br></pre></td></tr></table></figure>

<h1 id="四-总结"><a href="#四-总结" class="headerlink" title="四. 总结"></a>四. 总结</h1><p>其实以上配置还有很多漏洞, 比如token的过期时间, 当用户上一秒还在请求数据, 下一秒token过期, 则会造成用户需要重新登录, 显然不合适</p>
<p>本人也是初学SpringSecurity, 以上这是个人的学习见解, 如有不足之处还望指出, 大佬勿喷!!!</p>
<p>这是项目的地址 <a  href ="https://github.com/SweiJ/Java_Daily/tree/master/secsys">Github下载</a></p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    

    </div>

    
  </div>
</article>

  









    </main>

    <footer class="site-footer">
  <p class="site-info">
    Proudly powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and
    Theme by <a href="https://github.com/CodeDaraW/Hacker" target="_blank">Hacker</a>
    </br>
    
    &copy; 2023 Swei
    
  </p>
</footer>
    
    
  </div>
</div>
</body>
</html>